<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demucs Audio Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .file-selector {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .file-selector label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #555;
        }

        .file-selector input[type="file"] {
            width: 100%;
            padding: 10px;
            border: 2px dashed #667eea;
            border-radius: 8px;
            background: white;
            cursor: pointer;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .play-button {
            padding: 15px 40px;
            font-size: 18px;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            background: #667eea;
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .play-button:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .play-button:active {
            transform: translateY(0);
        }

        .play-button.playing {
            background: #e74c3c;
        }

        .tracks {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .track {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            border: 2px solid transparent;
            transition: all 0.3s;
        }

        .track:hover {
            border-color: #667eea;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.2);
        }

        .track.muted {
            opacity: 0.5;
            background: #e9ecef;
        }

        .track-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .track-icon {
            width: 50px;
            height: 50px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: white;
        }

        .track-icon.drums { background: #e74c3c; }
        .track-icon.bass { background: #3498db; }
        .track-icon.guitar { background: #9b59b6; }
        .track-icon.piano { background: #1abc9c; }
        .track-icon.other { background: #2ecc71; }
        .track-icon.vocals { background: #f39c12; }

        .track-name {
            flex: 1;
            font-size: 20px;
            font-weight: 600;
            color: #333;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 5px;
            transition: background 0.3s;
        }

        .track-name:hover {
            background: rgba(102, 126, 234, 0.1);
        }

        .track-name-input {
            flex: 1;
            font-size: 20px;
            font-weight: 600;
            color: #333;
            border: 2px solid #667eea;
            border-radius: 5px;
            padding: 5px 10px;
            outline: none;
        }

        .mute-button {
            padding: 10px 20px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .mute-button:hover {
            background: #667eea;
            color: white;
        }

        .mute-button.muted {
            background: #e74c3c;
            border-color: #e74c3c;
            color: white;
        }

        .solo-button {
            padding: 10px 20px;
            border: 2px solid #2ecc71;
            background: white;
            color: #2ecc71;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .solo-button:hover {
            background: #2ecc71;
            color: white;
        }

        .solo-button.active {
            background: #2ecc71;
            border-color: #2ecc71;
            color: white;
        }

        .track.soloed {
            border-color: #2ecc71;
            box-shadow: 0 4px 15px rgba(46, 204, 113, 0.3);
        }

        .export-button {
            padding: 15px 40px;
            font-size: 18px;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            background: #2ecc71;
            color: white;
            box-shadow: 0 4px 15px rgba(46, 204, 113, 0.4);
        }

        .export-button:hover {
            background: #27ae60;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(46, 204, 113, 0.6);
        }

        .export-button:active {
            transform: translateY(0);
        }

        .export-button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .track-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .volume-control {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .volume-label {
            min-width: 60px;
            font-weight: 600;
            color: #666;
        }

        .volume-slider {
            flex: 1;
            height: 8px;
            border-radius: 4px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            transition: all 0.3s;
        }

        .volume-slider::-webkit-slider-thumb:hover {
            background: #5568d3;
            transform: scale(1.2);
        }

        .volume-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }

        .volume-value {
            min-width: 45px;
            text-align: right;
            font-weight: 600;
            color: #667eea;
        }

        .progress-container {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            border-radius: 5px;
            background: #ddd;
            cursor: pointer;
            position: relative;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            border-radius: 5px;
            width: 0%;
            transition: width 0.1s;
        }

        .time-display {
            display: flex;
            justify-content: space-between;
            font-weight: 600;
            color: #666;
            font-size: 14px;
        }

        .status {
            text-align: center;
            padding: 15px;
            margin-top: 20px;
            border-radius: 8px;
            font-weight: 600;
        }

        .status.loading {
            background: #fff3cd;
            color: #856404;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
        }

        .upload-area {
            margin-bottom: 30px;
            padding: 40px;
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
            border: 3px dashed #667eea;
            border-radius: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-area:hover {
            background: linear-gradient(135deg, #667eea25 0%, #764ba225 100%);
            border-color: #5568d3;
            transform: translateY(-2px);
        }

        .upload-area.dragover {
            background: linear-gradient(135deg, #667eea35 0%, #764ba235 100%);
            border-color: #2ecc71;
        }

        .upload-icon {
            font-size: 60px;
            margin-bottom: 15px;
        }

        .upload-text {
            font-size: 18px;
            font-weight: 600;
            color: #667eea;
            margin-bottom: 10px;
        }

        .upload-hint {
            font-size: 14px;
            color: #666;
        }

        .upload-file-input {
            display: none;
        }

        .choose-file-button {
            padding: 12px 30px;
            font-size: 16px;
            font-weight: 600;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 15px;
            position: relative;
            z-index: 10;
        }

        .choose-file-button:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
        }

        .choose-file-button:active {
            transform: translateY(0);
        }

        .separator-button {
            padding: 15px 40px;
            font-size: 18px;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            margin-top: 15px;
        }

        .separator-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .separator-button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }

        .progress-info {
            margin-top: 15px;
            padding: 15px;
            background: #fff;
            border-radius: 8px;
            display: none;
        }

        .progress-info.active {
            display: block;
        }

        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(102, 126, 234, 0.3);
            border-radius: 50%;
            border-top-color: #667eea;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .directory-selector {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #2ecc71;
            display: none;
        }

        .directory-selector.active {
            display: block;
        }

        .directory-selector label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }

        .directory-selector input {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-family: monospace;
        }

        .load-button {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .load-button:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }

        .load-button:active {
            transform: translateY(0);
        }

        .child-track {
            margin-left: 30px;
            border-left: 3px solid #667eea;
            padding-left: 15px;
            opacity: 0.9;
        }

        .children-container {
            margin-top: 10px;
            padding-left: 20px;
        }

        .collapse-button {
            padding: 5px 10px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            font-size: 12px;
            transition: all 0.3s;
        }

        .collapse-button:hover {
            background: #667eea;
            color: white;
        }

        .track-icon.mix {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ Demucs Audio Separator</h1>

        <div class="upload-area" id="upload-area">
            <div class="upload-icon">üéµ</div>
            <div class="upload-text">Drag & drop your audio file here</div>
            <div class="upload-hint">Supports MP3, WAV, AIFF, FLAC (max 500MB)</div>
            <input type="file" id="upload-input" class="upload-file-input" accept=".mp3,.wav,.aiff,.aif,.flac,.m4a,.ogg">
            <button class="choose-file-button" id="choose-file-button">üìÅ Choose File</button>
            <div id="splitter-selector" style="display: none; margin-top: 15px;">
                <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                    <div>
                        <label style="font-weight: 600; color: #667eea; margin-right: 10px;">Splitter:</label>
                        <select id="splitter-select" style="padding: 8px 15px; border: 2px solid #667eea; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; min-width: 150px;">
                            <option value="">Loading...</option>
                        </select>
                    </div>
                    <div>
                        <label style="font-weight: 600; color: #667eea; margin-right: 10px;">Model:</label>
                        <select id="model-select" style="padding: 8px 15px; border: 2px solid #667eea; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; min-width: 200px;">
                            <option value="">Select splitter first</option>
                        </select>
                    </div>
                </div>
            </div>
            <button class="separator-button" id="separate-button" style="display: none;">‚ú® Separate Audio into Stems</button>
            <div class="progress-info" id="progress-info">
                <div class="spinner"></div>
                <span id="progress-text">Processing...</span>
            </div>
        </div>

        <div class="directory-selector" id="directory-selector">
            <label for="directory-input">Or load existing separated audio:</label>
            <div style="display: flex; gap: 10px; align-items: center;">
                <input type="text" id="directory-input" placeholder="separated/htdemucs/01 Benediction" value="/Users/jasonryan/Documents/sound2/separated/htdemucs_6s" style="flex: 1;">
                <button class="browse-button" id="browse-button" style="padding: 10px 20px; background: #3498db; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">üìÅ Browse</button>
                <button class="load-button" id="load-button" style="padding: 10px 20px; background: #2ecc71; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">Load</button>
            </div>
            <div id="folder-browser" style="display: none; margin-top: 15px; padding: 15px; background: white; border: 2px solid #3498db; border-radius: 8px; max-height: 300px; overflow-y: auto;">
                <div style="margin-bottom: 10px; font-weight: 600; color: #3498db;">Select a song folder:</div>
                <div id="folder-list"></div>
            </div>
        </div>

        <div class="controls">
            <button class="play-button" id="play-button">‚ñ∂ Play</button>
            <button class="separator-button" id="scan-button" style="display: none;">üîç Scan & Label Stems</button>
            <button class="export-button" id="export-button">üíæ Export Mixed Audio</button>
        </div>

        <div id="status"></div>

        <div style="margin-bottom: 15px;">
            <button id="add-stem-button" style="padding: 10px 20px; background: #3498db; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; display: none;">‚ûï Add Stem</button>
            <input type="file" id="add-stem-input" accept=".mp3,.wav,.aiff,.aif,.flac,.m4a,.ogg" style="display: none;">
        </div>
        <div class="tracks" id="tracks-container"></div>

        <div class="progress-container">
            <div class="progress-bar" id="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div class="time-display">
                <span id="current-time">0:00</span>
                <span id="total-time">0:00</span>
            </div>
        </div>
    </div>

    <script>
        class AudioEditor {
            constructor() {
                this.audioContext = null;
                this.sources = {};
                this.gainNodes = {};
                this.audioBuffers = {};
                this.isPlaying = false;
                this.startTime = 0;
                this.pauseTime = 0;
                this.tracks = ['drums', 'bass', 'guitar', 'piano', 'other', 'vocals'];  // 6 stems
                this.currentTime = 0;
                this.duration = 0;
                this.soloedTracks = new Set();
                this.savedVolumes = {}; // Store volumes before solo
                this.uploadedFile = null;
                this.jobId = null;
                this.apiUrl = 'http://localhost:5001/api';
                this.trackLabels = {}; // Store custom labels for tracks
                this.availableSplitters = {}; // Available splitters and models
                this.currentManifest = null; // Current separation manifest
                this.state = 'idle'; // idle, uploading, separating, loading, ready, error
                this.trackTree = {}; // Track hierarchy: {mix: {...}, stems: [...], children: {...}}

                this.init();
            }

            async init() {
                this.setupEventListeners();
                this.createTrackUI();
                this.updateExportButton();

                // Load available splitters
                await this.loadSplitters();

                // Show directory selector by default
                document.getElementById('directory-selector').classList.add('active');
            }

            setupEventListeners() {
                document.getElementById('play-button').addEventListener('click', () => this.togglePlay());
                document.getElementById('export-button').addEventListener('click', () => this.exportAudio());
                document.getElementById('scan-button').addEventListener('click', () => this.scanStems());
                document.getElementById('load-button').addEventListener('click', () => this.loadFromDirectory());
                document.getElementById('browse-button').addEventListener('click', () => this.browseFolders());
                document.getElementById('directory-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.loadFromDirectory();
                    }
                });
                document.getElementById('progress-bar').addEventListener('click', (e) => this.seek(e));
                
                // Add stem button
                document.getElementById('add-stem-button').addEventListener('click', () => {
                    document.getElementById('add-stem-input').click();
                });
                document.getElementById('add-stem-input').addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.addStem(e.target.files[0]);
                    }
                });

                // Upload area listeners
                const uploadArea = document.getElementById('upload-area');
                const uploadInput = document.getElementById('upload-input');
                const chooseFileButton = document.getElementById('choose-file-button');
                const separateButton = document.getElementById('separate-button');

                // Choose file button
                chooseFileButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    console.log('Choose file button clicked');
                    uploadInput.click();
                });

                uploadInput.addEventListener('change', (e) => {
                    console.log('File selected:', e.target.files[0]);
                    this.handleFileSelect(e.target.files[0]);
                });

                // Drag and drop
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });

                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });

                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    const file = e.dataTransfer.files[0];
                    this.handleFileSelect(file);
                });

                separateButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.separateAudio();
                });

                // Splitter selector change handler
                document.getElementById('splitter-select').addEventListener('change', () => this.updateModelSelector());
            }

            async loadSplitters() {
                try {
                    const response = await fetch(`${this.apiUrl}/splitters`);
                    if (!response.ok) {
                        throw new Error('Failed to load splitters');
                    }
                    const data = await response.json();
                    this.availableSplitters = data.splitters || {};
                    this.populateSplitterSelector();
                } catch (error) {
                    console.error('Error loading splitters:', error);
                    this.showStatus('Failed to load available splitters', 'error');
                    // Fallback to Demucs only
                    this.availableSplitters = {
                        'demucs': {
                            'name': 'Demucs',
                            'models': [
                                {'id': 'htdemucs_6s', 'name': '6 Stems (Standard)'},
                                {'id': 'htdemucs_ft', 'name': '4 Stems (Fine-Tuned)'},
                                {'id': 'htdemucs', 'name': '4 Stems (Standard)'},
                            ]
                        }
                    };
                    this.populateSplitterSelector();
                }
            }

            populateSplitterSelector() {
                const splitterSelect = document.getElementById('splitter-select');
                splitterSelect.innerHTML = '';

                for (const [id, splitter] of Object.entries(this.availableSplitters)) {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = `${splitter.name} - ${splitter.description || ''}`;
                    splitterSelect.appendChild(option);
                }

                // Select first splitter by default
                if (splitterSelect.options.length > 0) {
                    splitterSelect.value = splitterSelect.options[0].value;
                    this.updateModelSelector();
                }
            }

            updateModelSelector() {
                const splitterSelect = document.getElementById('splitter-select');
                const modelSelect = document.getElementById('model-select');
                const selectedSplitter = splitterSelect.value;

                modelSelect.innerHTML = '';

                if (selectedSplitter && this.availableSplitters[selectedSplitter]) {
                    const splitter = this.availableSplitters[selectedSplitter];
                    splitter.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id;
                        option.textContent = model.name;
                        modelSelect.appendChild(option);
                    });
                } else {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = 'Select splitter first';
                    modelSelect.appendChild(option);
                }
            }

            handleFileSelect(file) {
                if (!file) return;

                const validTypes = ['audio/mpeg', 'audio/wav', 'audio/aiff', 'audio/x-aiff', 'audio/flac', 'audio/mp4', 'audio/ogg'];
                const validExtensions = ['.mp3', '.wav', '.aiff', '.aif', '.flac', '.m4a', '.ogg'];
                const fileName = file.name.toLowerCase();
                const hasValidExtension = validExtensions.some(ext => fileName.endsWith(ext));

                if (!hasValidExtension && !validTypes.includes(file.type)) {
                    this.showStatus('Invalid file type. Please upload MP3, WAV, AIFF, or FLAC.', 'error');
                    return;
                }

                this.uploadedFile = file;
                document.querySelector('.upload-text').textContent = `Selected: ${file.name}`;
                document.querySelector('.upload-hint').textContent = `Size: ${(file.size / 1024 / 1024).toFixed(2)} MB`;
                document.getElementById('splitter-selector').style.display = 'block';
                document.getElementById('separate-button').style.display = 'inline-block';
            }

            async separateAudio() {
                if (!this.uploadedFile) {
                    this.showStatus('Please select a file first', 'error');
                    return;
                }

                const separateButton = document.getElementById('separate-button');
                const progressInfo = document.getElementById('progress-info');
                const progressText = document.getElementById('progress-text');

                try {
                    this.setState('uploading');
                    separateButton.disabled = true;
                    progressInfo.classList.add('active');
                    progressText.textContent = 'Uploading file...';

                    // Upload file
                    const formData = new FormData();
                    formData.append('file', this.uploadedFile);

                    const uploadResponse = await fetch(`${this.apiUrl}/upload`, {
                        method: 'POST',
                        body: formData
                    });

                    if (!uploadResponse.ok) {
                        const error = await uploadResponse.json();
                        throw new Error(error.error || 'Upload failed');
                    }

                    const uploadData = await uploadResponse.json();
                    this.jobId = uploadData.job_id;

                    // Get selected splitter and model
                    const selectedSplitter = document.getElementById('splitter-select').value;
                    const selectedModel = document.getElementById('model-select').value;

                    if (!selectedSplitter || !selectedModel) {
                        throw new Error('Please select a splitter and model');
                    }

                    const splitterInfo = this.availableSplitters[selectedSplitter];
                    const modelInfo = splitterInfo.models.find(m => m.id === selectedModel);
                    const modelName = modelInfo ? modelInfo.name : selectedModel;

                    this.setState('separating');
                    progressText.textContent = `Separating audio with ${splitterInfo.name} (${modelName})... This may take a few minutes.`;

                    // Start separation with selected splitter and model
                    const separateResponse = await fetch(`${this.apiUrl}/separate/${this.jobId}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ 
                            splitter: selectedSplitter,
                            model: selectedModel 
                        })
                    });

                    if (!separateResponse.ok) {
                        const error = await separateResponse.json();
                        throw new Error(error.error || 'Separation failed');
                    }

                    const manifest = await separateResponse.json();

                    if (manifest.error) {
                        throw new Error(manifest.error);
                    }

                    this.setState('loading');
                    progressText.textContent = 'Loading separated stems...';

                    // Store manifest
                    this.currentManifest = manifest;

                    // Load stems from manifest (HTTP paths)
                    await this.loadFromManifest(manifest);

                    progressInfo.classList.remove('active');
                    this.showStatus(`‚ú® Successfully separated into ${manifest.stems.length} stems using ${manifest.splitter}!`, 'success');

                    // Show scan button
                    document.getElementById('scan-button').style.display = 'inline-block';

                    // Reset upload UI
                    document.querySelector('.upload-text').textContent = 'Drop audio file here or click to upload';
                    document.querySelector('.upload-hint').textContent = 'Supports MP3, WAV, AIFF, FLAC (max 500MB)';
                    separateButton.style.display = 'none';
                    this.uploadedFile = null;

                } catch (error) {
                    this.setState('error');
                    progressInfo.classList.remove('active');
                    this.showStatus(`Error: ${error.message}`, 'error');
                    console.error('Separation error:', error);
                } finally {
                    separateButton.disabled = false;
                }
            }

            async splitVocals() {
                if (!this.jobId) {
                    this.showStatus('No job ID available', 'error');
                    return;
                }

                try {
                    this.setState('separating');
                    this.showStatus('üé§ Splitting vocals... This may take 2-3 minutes.', 'loading');

                    const response = await fetch(`${this.apiUrl}/split-vocals/${this.jobId}`, {
                        method: 'POST'
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error || 'Vocal split failed');
                    }

                    const manifest = await response.json();

                    // Merge child splits into current manifest
                    if (manifest.child_splits && this.currentManifest) {
                        if (!this.currentManifest.child_splits) {
                            this.currentManifest.child_splits = {};
                        }
                        Object.assign(this.currentManifest.child_splits, manifest.child_splits);
                    }

                    // Reload manifest to include child stems
                    this.setState('loading');
                    await this.loadFromManifest(this.currentManifest);

                    this.showStatus('‚úÖ Vocals split complete!', 'success');

                } catch (error) {
                    this.setState('error');
                    this.showStatus(`Error: ${error.message}`, 'error');
                    console.error('Split error:', error);
                }
            }

            async splitDrums() {
                if (!this.jobId) {
                    this.showStatus('No job ID available', 'error');
                    return;
                }

                try {
                    this.setState('separating');
                    this.showStatus('ü•Å Splitting drums... This may take 2-3 minutes.', 'loading');

                    const response = await fetch(`${this.apiUrl}/split-drums/${this.jobId}`, {
                        method: 'POST'
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error || 'Drum split failed');
                    }

                    const manifest = await response.json();

                    // Merge child splits into current manifest
                    if (manifest.child_splits && this.currentManifest) {
                        if (!this.currentManifest.child_splits) {
                            this.currentManifest.child_splits = {};
                        }
                        Object.assign(this.currentManifest.child_splits, manifest.child_splits);
                    }

                    // Reload manifest to include child stems
                    this.setState('loading');
                    await this.loadFromManifest(this.currentManifest);

                    this.showStatus('‚úÖ Drums split complete!', 'success');

                } catch (error) {
                    this.setState('error');
                    this.showStatus(`Error: ${error.message}`, 'error');
                    console.error('Split error:', error);
                }
            }

            async scanStems() {
                if (!this.jobId) {
                    this.showStatus('No job ID available for scanning', 'error');
                    return;
                }

                try {
                    this.showStatus('üîç Analyzing stems...', 'loading');

                    const response = await fetch(`${this.apiUrl}/analyze/${this.jobId}`, {
                        method: 'POST'
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error || 'Analysis failed');
                    }

                    const data = await response.json();

                    // Apply suggested labels
                    for (const [track, label] of Object.entries(data.labels)) {
                        this.trackLabels[track] = label;

                        // Update UI
                        const trackNameEl = document.querySelector(`.track-name[data-track="${track}"]`);
                        if (trackNameEl) {
                            trackNameEl.textContent = label;
                        }
                    }

                    this.showStatus('‚úÖ Stems analyzed and labeled!', 'success');

                } catch (error) {
                    this.showStatus(`Analysis error: ${error.message}`, 'error');
                    console.error('Scan error:', error);
                }
            }

            async browseFolders() {
                const basePath = document.getElementById('directory-input').value.trim();
                if (!basePath) {
                    this.showStatus('Please enter a base directory path first', 'error');
                    return;
                }

                try {
                    const response = await fetch(`${this.apiUrl}/browse-folders`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({path: basePath})
                    });

                    const data = await response.json();
                    if (!response.ok) {
                        this.showStatus(`Error: ${data.error}`, 'error');
                        return;
                    }

                    const folderBrowser = document.getElementById('folder-browser');
                    const folderList = document.getElementById('folder-list');

                    if (data.folders.length === 0) {
                        folderList.innerHTML = '<div style="color: #999; padding: 10px;">No subdirectories found</div>';
                    } else {
                        folderList.innerHTML = data.folders.map(folder => `
                            <div class="folder-item" data-path="${folder.path}" style="padding: 12px; margin: 5px 0; background: #f8f9fa; border-radius: 6px; cursor: pointer; transition: all 0.2s; border: 2px solid transparent;">
                                üìÅ ${folder.name}
                            </div>
                        `).join('');

                        // Add click handlers
                        folderList.querySelectorAll('.folder-item').forEach(item => {
                            item.addEventListener('click', () => {
                                document.getElementById('directory-input').value = item.dataset.path;
                                folderBrowser.style.display = 'none';
                                this.loadFromDirectory();
                            });
                            item.addEventListener('mouseenter', (e) => {
                                e.target.style.background = '#e3f2fd';
                                e.target.style.borderColor = '#3498db';
                            });
                            item.addEventListener('mouseleave', (e) => {
                                e.target.style.background = '#f8f9fa';
                                e.target.style.borderColor = 'transparent';
                            });
                        });
                    }

                    folderBrowser.style.display = 'block';

                } catch (error) {
                    this.showStatus(`Browse error: ${error.message}`, 'error');
                    console.error('Browse error:', error);
                }
            }

            async loadFromManifest(manifest) {
                if (!manifest) {
                    this.showStatus('Invalid manifest', 'error');
                    return;
                }

                this.showStatus('Loading audio files from manifest...', 'loading');

                try {
                    const files = {};
                    const loadUrl = (url) => {
                        if (!url.startsWith('http')) {
                            if (url.startsWith('/api')) {
                                return `http://localhost:5001${url}`;
                            } else {
                                return `${this.apiUrl}${url}`;
                            }
                        }
                        return url;
                    };
                    
                    // Load mix track if available
                    if (manifest.mix && manifest.mix.url) {
                        try {
                            const mixUrl = loadUrl(manifest.mix.url);
                            const response = await fetch(mixUrl);
                            if (response.ok) {
                                const arrayBuffer = await response.arrayBuffer();
                                const contentType = response.headers.get('content-type') || 'audio/mpeg';
                                files['mix'] = new File([arrayBuffer], 'mix', { type: contentType });
                            }
                        } catch (e) {
                            console.warn(`Could not load mix:`, e);
                        }
                    }
                    
                    // Load stems from manifest URLs
                    for (const stemInfo of manifest.stems) {
                        const stemName = stemInfo.name;
                        const stemUrl = loadUrl(stemInfo.url);
                        
                        try {
                            const response = await fetch(stemUrl);
                            if (response.ok) {
                                const arrayBuffer = await response.arrayBuffer();
                                const contentType = response.headers.get('content-type') || 'audio/mpeg';
                                const filename = `${stemName}.${contentType.includes('wav') ? 'wav' : 'mp3'}`;
                                files[stemName] = new File([arrayBuffer], filename, { type: contentType });
                            }
                        } catch (e) {
                            console.warn(`Could not load ${stemName} from ${stemUrl}:`, e);
                        }
                    }

                    // Load child stems (from secondary splits)
                    if (manifest.child_splits) {
                        for (const [parent, children] of Object.entries(manifest.child_splits)) {
                            for (const childInfo of children) {
                                const childName = `${parent}_${childInfo.name}`;
                                const childUrl = loadUrl(childInfo.url);
                                
                                try {
                                    const response = await fetch(childUrl);
                                    if (response.ok) {
                                        const arrayBuffer = await response.arrayBuffer();
                                        const contentType = response.headers.get('content-type') || 'audio/mpeg';
                                        const filename = `${childName}.${contentType.includes('wav') ? 'wav' : 'mp3'}`;
                                        files[childName] = new File([arrayBuffer], filename, { type: contentType });
                                    }
                                } catch (e) {
                                    console.warn(`Could not load child ${childName}:`, e);
                                }
                            }
                        }
                    }

                    if (Object.keys(files).length === 0) {
                        this.showStatus('No stems could be loaded from manifest', 'error');
                        return;
                    }

                    // Store manifest for track tree
                    this.currentManifest = manifest;
                    this.trackTree = {
                        mix: manifest.mix,
                        stems: manifest.stems || [],
                        children: manifest.child_splits || {}
                    };

                    // Update tracks list - include mix first, then stems
                    const trackList = [];
                    if (files['mix']) trackList.push('mix');
                    trackList.push(...Object.keys(files).filter(k => k !== 'mix' && !k.includes('_')));
                    
                    // Add child tracks
                    for (const [parent, children] of Object.entries(this.trackTree.children)) {
                        for (const child of children) {
                            const childName = `${parent}_${child.name}`;
                            if (files[childName]) {
                                trackList.push(childName);
                            }
                        }
                    }

                    this.tracks = trackList;
                    
                    // Recreate track UI with new tracks
                    this.createTrackUI();
                    await this.loadAudioFiles(files);
                    this.setState('ready');
                    this.showStatus(`Loaded ${Object.keys(files).length} track(s)`, 'success');
                } catch (error) {
                    this.setState('error');
                    this.showStatus(`Error loading from manifest: ${error.message}`, 'error');
                    console.error('Manifest load error:', error);
                }
            }

            async loadFromDirectory() {
                const dir = document.getElementById('directory-input').value.trim();
                if (!dir) {
                    this.showStatus('Please enter a directory path', 'error');
                    return;
                }

                this.setState('loading');
                this.showStatus('Loading project...', 'loading');
                
                try {
                    // Use the new load-project endpoint
                    const response = await fetch(`${this.apiUrl}/load-project`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({path: dir})
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error || 'Failed to load project');
                    }

                    const manifest = await response.json();
                    this.currentManifest = manifest;
                    this.jobId = manifest.job_id;

                    // Load from manifest
                    await this.loadFromManifest(manifest);
                    this.setState('ready');
                } catch (error) {
                    this.setState('error');
                    this.showStatus(`Error loading project: ${error.message}`, 'error');
                    console.error('Load error:', error);
                }
            }

            setState(newState) {
                this.state = newState;
                this.updateUIForState();
            }

            updateUIForState() {
                const playButton = document.getElementById('play-button');
                const exportButton = document.getElementById('export-button');
                const separateButton = document.getElementById('separate-button');
                const addStemButton = document.getElementById('add-stem-button');

                // Enable/disable buttons based on state
                playButton.disabled = this.state !== 'ready';
                exportButton.disabled = this.state !== 'ready';
                
                // Show add stem button when ready
                if (this.state === 'ready' && this.jobId) {
                    addStemButton.style.display = 'inline-block';
                } else {
                    addStemButton.style.display = 'none';
                }

                // Update status display
                const statusMessages = {
                    'idle': '',
                    'uploading': 'Uploading file...',
                    'separating': 'Separating audio...',
                    'loading': 'Loading stems...',
                    'ready': 'Ready to play',
                    'error': 'An error occurred'
                };
            }

            async addStem(file) {
                if (!this.jobId) {
                    this.showStatus('No active project. Please load or create a project first.', 'error');
                    return;
                }

                const stemName = prompt('Enter stem name (or leave blank to infer from filename):', '');
                const finalStemName = stemName.trim() || file.name.replace(/\.[^/.]+$/, '').toLowerCase();

                try {
                    this.showStatus(`Adding stem ${finalStemName}...`, 'loading');

                    const formData = new FormData();
                    formData.append('file', file);
                    formData.append('stem_name', finalStemName);

                    const response = await fetch(`${this.apiUrl}/add-stem/${this.jobId}`, {
                        method: 'POST',
                        body: formData
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error || 'Failed to add stem');
                    }

                    const data = await response.json();

                    // Load the new stem
                    const loadUrl = data.url.startsWith('/api') ? `http://localhost:5001${data.url}` : `${this.apiUrl}${data.url}`;
                    const stemResponse = await fetch(loadUrl);
                    if (stemResponse.ok) {
                        const arrayBuffer = await stemResponse.arrayBuffer();
                        const contentType = stemResponse.headers.get('content-type') || 'audio/mpeg';
                        const stemFile = new File([arrayBuffer], `${finalStemName}.${contentType.includes('wav') ? 'wav' : 'mp3'}`, { type: contentType });

                        // Add to audio buffers
                        if (!this.audioContext) {
                            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        }
                        const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                        this.audioBuffers[finalStemName] = audioBuffer;

                        // Create gain node
                        if (!this.gainNodes[finalStemName]) {
                            this.gainNodes[finalStemName] = this.audioContext.createGain();
                            this.gainNodes[finalStemName].connect(this.audioContext.destination);
                            this.gainNodes[finalStemName].gain.value = 1.0;
                        }

                        // Add to tracks if not already present
                        if (!this.tracks.includes(finalStemName)) {
                            this.tracks.push(finalStemName);
                        }

                        // Update manifest
                        if (this.currentManifest) {
                            if (!this.currentManifest.stems) {
                                this.currentManifest.stems = [];
                            }
                            // Check if stem already exists
                            const existingIndex = this.currentManifest.stems.findIndex(s => s.name === finalStemName);
                            if (existingIndex >= 0) {
                                this.currentManifest.stems[existingIndex] = {
                                    name: finalStemName,
                                    url: data.url,
                                    path: data.path
                                };
                            } else {
                                this.currentManifest.stems.push({
                                    name: finalStemName,
                                    url: data.url,
                                    path: data.path
                                });
                            }
                        }

                        // Recreate UI
                        this.createTrackUI();
                        this.updateExportButton();

                        this.showStatus(`‚úÖ Stem ${finalStemName} added successfully!`, 'success');
                    }

                } catch (error) {
                    this.showStatus(`Error adding stem: ${error.message}`, 'error');
                    console.error('Add stem error:', error);
                }
            }

            async loadFiles(fileList) {
                const files = {};
                Array.from(fileList).forEach(file => {
                    const name = file.name.toLowerCase();
                    for (const track of this.tracks) {
                        if (name.includes(track)) {
                            files[track] = file;
                            break;
                        }
                    }
                });

                if (Object.keys(files).length === 0) {
                    this.showStatus('No matching track files found. Looking for: drums, bass, other, vocals', 'error');
                    return;
                }

                this.showStatus('Loading audio files...', 'loading');
                try {
                    await this.loadAudioFiles(files);
                    this.showStatus(`Loaded ${Object.keys(files).length} track(s)`, 'success');
                } catch (error) {
                    this.showStatus(`Error loading files: ${error.message}`, 'error');
                    console.error('Load error:', error);
                }
            }

            async loadAudioFiles(files) {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                // Stop and clear existing sources
                this.stop();

                // Load audio buffers
                for (const [track, file] of Object.entries(files)) {
                    try {
                        const arrayBuffer = await file.arrayBuffer();
                        const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                        this.audioBuffers[track] = audioBuffer;
                        
                        // Update duration to the longest track
                        if (audioBuffer.duration > this.duration) {
                            this.duration = audioBuffer.duration;
                        }
                    } catch (error) {
                        console.error(`Error loading ${track}:`, error);
                    }
                }

                // Create gain nodes for all loaded tracks (including mix and child tracks)
                const allTracks = Object.keys(this.audioBuffers);
                for (const track of allTracks) {
                    if (!this.gainNodes[track]) {
                        this.gainNodes[track] = this.audioContext.createGain();
                        this.gainNodes[track].connect(this.audioContext.destination);
                        this.gainNodes[track].gain.value = 1.0;
                    }
                }

                this.updateTotalTime();
                this.updateExportButton();
            }

            updateExportButton() {
                const exportButton = document.getElementById('export-button');
                exportButton.disabled = Object.keys(this.audioBuffers).length === 0;
            }

            createTrackUI() {
                const container = document.getElementById('tracks-container');
                container.innerHTML = '';

                const icons = {
                    mix: 'üéöÔ∏è',
                    drums: 'ü•Å',
                    bass: 'üé∏',
                    guitar: 'üé∏',
                    piano: 'üéπ',
                    other: 'üéµ',
                    vocals: 'üé§'
                };

                // Helper to create a track element
                const createTrackElement = (track, isChild = false, parentTrack = null) => {
                    const trackDiv = document.createElement('div');
                    trackDiv.className = `track ${isChild ? 'child-track' : ''}`;
                    trackDiv.id = `track-${track}`;
                    if (isChild) {
                        trackDiv.style.marginLeft = '30px';
                        trackDiv.style.borderLeft = '3px solid #667eea';
                        trackDiv.style.paddingLeft = '15px';
                    }

                    const baseTrackName = parentTrack ? track.replace(`${parentTrack}_`, '') : track;
                    const displayName = this.trackLabels[track] || baseTrackName.charAt(0).toUpperCase() + baseTrackName.slice(1);

                    // Add split dropdown for vocals and drums tracks (only for parent tracks)
                    let splitDropdown = '';
                    if (!isChild && (track === 'vocals' || track === 'drums')) {
                        splitDropdown = `
                            <select class="split-select" data-track="${track}" style="padding: 10px 15px; border: 2px solid ${track === 'vocals' ? '#9b59b6' : '#e74c3c'}; background: white; color: ${track === 'vocals' ? '#9b59b6' : '#e74c3c'}; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px;">
                                <option value="">${track === 'vocals' ? 'üé§' : 'ü•Å'} Split ${track.charAt(0).toUpperCase() + track.slice(1)}...</option>
                                <option value="split">‚Üí Split</option>
                            </select>`;
                    }

                    // Collapse/expand button for tracks with children
                    let collapseButton = '';
                    if (!isChild && this.trackTree.children && this.trackTree.children[track]) {
                        const children = this.trackTree.children[track];
                        if (children && children.length > 0) {
                            collapseButton = `<button class="collapse-button" data-track="${track}" style="padding: 5px 10px; border: 2px solid #667eea; background: white; color: #667eea; border-radius: 5px; cursor: pointer; font-weight: 600; font-size: 12px;">‚ñº</button>`;
                        }
                    }

                    trackDiv.innerHTML = `
                        <div class="track-header">
                            ${isChild ? '<span style="color: #667eea; margin-right: 5px;">‚îî‚îÄ</span>' : ''}
                            <div class="track-icon ${baseTrackName}">${icons[baseTrackName] || 'üéµ'}</div>
                            <div class="track-name" data-track="${track}" title="Click to rename">${displayName}</div>
                            ${collapseButton}
                            <button class="solo-button" data-track="${track}">Solo</button>
                            <button class="mute-button" data-track="${track}">Mute</button>
                            ${splitDropdown}
                            <button class="export-stem-button" data-track="${track}" style="padding: 10px 20px; border: 2px solid #2ecc71; background: white; color: #2ecc71; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s;">üíæ Export</button>
                        </div>
                        <div class="track-controls">
                            <div class="volume-control">
                                <span class="volume-label">Volume:</span>
                                <input type="range" class="volume-slider"
                                       data-track="${track}"
                                       min="0" max="100" value="100">
                                <span class="volume-value" id="volume-${track}">100%</span>
                            </div>
                        </div>
                    `;

                    return trackDiv;
                };

                // Render mix track first if available
                if (this.audioBuffers['mix']) {
                    const mixDiv = createTrackElement('mix');
                    container.appendChild(mixDiv);
                    this.setupTrackListeners(mixDiv, 'mix');
                }

                // Render parent stems
                const parentTracks = this.tracks.filter(t => t !== 'mix' && !t.includes('_'));
                parentTracks.forEach(track => {
                    const trackDiv = createTrackElement(track);
                    container.appendChild(trackDiv);
                    this.setupTrackListeners(trackDiv, track);

                    // Render child tracks if they exist
                    if (this.trackTree.children && this.trackTree.children[track]) {
                        const children = this.trackTree.children[track];
                        const childTracks = this.tracks.filter(t => t.startsWith(`${track}_`));
                        
                        // Create a container for children (initially hidden)
                        const childrenContainer = document.createElement('div');
                        childrenContainer.className = 'children-container';
                        childrenContainer.id = `children-${track}`;
                        childrenContainer.style.display = 'none';
                        
                        childTracks.forEach(childTrack => {
                            const childDiv = createTrackElement(childTrack, true, track);
                            childrenContainer.appendChild(childDiv);
                            this.setupTrackListeners(childDiv, childTrack);
                        });
                        
                        if (childTracks.length > 0) {
                            trackDiv.appendChild(childrenContainer);
                            
                            // Setup collapse button
                            const collapseButton = trackDiv.querySelector('.collapse-button');
                            if (collapseButton) {
                                collapseButton.addEventListener('click', () => {
                                    const isHidden = childrenContainer.style.display === 'none';
                                    childrenContainer.style.display = isHidden ? 'block' : 'none';
                                    collapseButton.textContent = isHidden ? '‚ñ≤' : '‚ñº';
                                });
                            }
                        }
                    }
                });
            }

            setupTrackListeners(trackDiv, track) {
                const trackNameEl = trackDiv.querySelector('.track-name');
                const soloButton = trackDiv.querySelector('.solo-button');
                const muteButton = trackDiv.querySelector('.mute-button');
                const splitSelect = trackDiv.querySelector('.split-select');
                const exportButton = trackDiv.querySelector('.export-stem-button');
                const volumeSlider = trackDiv.querySelector('.volume-slider');
                const volumeValue = trackDiv.querySelector(`#volume-${track}`);

                if (trackNameEl) {
                    trackNameEl.addEventListener('click', () => this.editTrackName(track, trackNameEl));
                }

                if (soloButton) {
                    soloButton.addEventListener('click', () => this.toggleSolo(track));
                }

                if (muteButton) {
                    muteButton.addEventListener('click', () => this.toggleMute(track));
                }

                if (splitSelect) {
                    splitSelect.addEventListener('change', (e) => {
                        const action = e.target.value;
                        const trackType = e.target.dataset.track;
                        if (action === 'split') {
                            if (trackType === 'vocals') {
                                this.splitVocals();
                            } else if (trackType === 'drums') {
                                this.splitDrums();
                            }
                            e.target.value = '';
                        }
                    });
                }

                if (exportButton) {
                    exportButton.addEventListener('click', () => this.exportStem(track));
                }

                if (volumeSlider && volumeValue) {
                    volumeSlider.addEventListener('input', (e) => {
                        const value = e.target.value;
                        volumeValue.textContent = `${value}%`;
                        this.setVolume(track, value / 100);
                    });
                }
            }

            editTrackName(track, element) {
                const currentName = this.trackLabels[track] || track.charAt(0).toUpperCase() + track.slice(1);

                // Create input element
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'track-name-input';
                input.value = currentName;

                // Replace the element
                element.replaceWith(input);
                input.focus();
                input.select();

                const saveEdit = () => {
                    const newName = input.value.trim();
                    if (newName && newName !== currentName) {
                        this.trackLabels[track] = newName;
                    }

                    // Restore the element
                    const nameEl = document.createElement('div');
                    nameEl.className = 'track-name';
                    nameEl.setAttribute('data-track', track);
                    nameEl.setAttribute('title', 'Click to rename');
                    nameEl.textContent = this.trackLabels[track] || track.charAt(0).toUpperCase() + track.slice(1);
                    nameEl.addEventListener('click', () => this.editTrackName(track, nameEl));
                    input.replaceWith(nameEl);
                };

                input.addEventListener('blur', saveEdit);
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        saveEdit();
                    } else if (e.key === 'Escape') {
                        // Restore without saving
                        const nameEl = document.createElement('div');
                        nameEl.className = 'track-name';
                        nameEl.setAttribute('data-track', track);
                        nameEl.setAttribute('title', 'Click to rename');
                        nameEl.textContent = currentName;
                        nameEl.addEventListener('click', () => this.editTrackName(track, nameEl));
                        input.replaceWith(nameEl);
                    }
                });
            }

            toggleSolo(track) {
                if (!this.gainNodes[track]) return;

                const trackDiv = document.getElementById(`track-${track}`);
                const soloButton = trackDiv.querySelector('.solo-button');
                const isSoloed = this.soloedTracks.has(track);

                if (isSoloed) {
                    // Turn off solo
                    this.soloedTracks.delete(track);
                    soloButton.classList.remove('active');
                    trackDiv.classList.remove('soloed');
                    
                    // Restore all tracks to their previous state
                    this.updateSoloState();
                } else {
                    // Turn on solo
                    this.soloedTracks.add(track);
                    soloButton.classList.add('active');
                    trackDiv.classList.add('soloed');
                    
                    // Save current volumes before solo
                    this.tracks.forEach(t => {
                        if (this.gainNodes[t] && !this.savedVolumes[t]) {
                            this.savedVolumes[t] = this.gainNodes[t].gain.value;
                        }
                    });
                    
                    // Update solo state
                    this.updateSoloState();
                }
            }

            updateSoloState() {
                const hasSolo = this.soloedTracks.size > 0;
                
                this.tracks.forEach(track => {
                    if (!this.gainNodes[track]) return;
                    
                    const trackDiv = document.getElementById(`track-${track}`);
                    const isSoloed = this.soloedTracks.has(track);
                    
                    if (hasSolo) {
                        // If any track is soloed, mute all non-soloed tracks
                        if (isSoloed) {
                            // Restore volume for soloed track
                            const savedVolume = this.savedVolumes[track] || 1.0;
                            this.gainNodes[track].gain.value = savedVolume;
                        } else {
                            // Mute non-soloed tracks
                            this.gainNodes[track].gain.value = 0;
                        }
                    } else {
                        // No solo active, restore all tracks
                        const savedVolume = this.savedVolumes[track];
                        if (savedVolume !== undefined) {
                            this.gainNodes[track].gain.value = savedVolume;
                        }
                    }
                });
                
                // Clear saved volumes if no solo is active
                if (!hasSolo) {
                    this.savedVolumes = {};
                }
            }

            toggleMute(track) {
                if (!this.gainNodes[track]) return;

                const trackDiv = document.getElementById(`track-${track}`);
                const muteButton = trackDiv.querySelector('.mute-button');
                const isMuted = this.gainNodes[track].gain.value === 0;

                if (isMuted) {
                    // Unmute - restore volume, but respect solo state
                    if (this.soloedTracks.size > 0 && !this.soloedTracks.has(track)) {
                        // Track is not soloed, keep muted
                        return;
                    }
                    const volume = this.savedVolumes[track] || 1.0;
                    this.gainNodes[track].gain.value = volume;
                    muteButton.textContent = 'Mute';
                    muteButton.classList.remove('muted');
                    trackDiv.classList.remove('muted');
                } else {
                    // Mute
                    this.savedVolumes[track] = this.gainNodes[track].gain.value;
                    this.gainNodes[track].gain.value = 0;
                    muteButton.textContent = 'Unmute';
                    muteButton.classList.add('muted');
                    trackDiv.classList.add('muted');
                }
            }

            setVolume(track, volume) {
                if (this.gainNodes[track]) {
                    // Save volume for later restoration
                    this.savedVolumes[track] = volume;
                    
                    // Only set volume if not muted and not affected by solo
                    const isMuted = this.gainNodes[track].gain.value === 0;
                    const hasSolo = this.soloedTracks.size > 0;
                    const isSoloed = this.soloedTracks.has(track);
                    
                    if (!isMuted && (!hasSolo || isSoloed)) {
                        this.gainNodes[track].gain.value = volume;
                    }
                }
            }

            togglePlay() {
                if (this.isPlaying) {
                    this.pause();
                } else {
                    this.play();
                }
            }

            play() {
                if (Object.keys(this.audioBuffers).length === 0) {
                    this.showStatus('Please load audio files first', 'error');
                    return;
                }

                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                // Resume audio context if suspended
                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }

                const currentTime = this.audioContext.currentTime;
                const offset = this.pauseTime;

                // Create and start sources for each track (including mix and child tracks)
                for (const track of this.tracks) {
                    if (this.audioBuffers[track] && this.gainNodes[track]) {
                        const source = this.audioContext.createBufferSource();
                        source.buffer = this.audioBuffers[track];
                        source.connect(this.gainNodes[track]);
                        
                        source.start(0, offset);
                        this.sources[track] = source;

                        source.onended = () => {
                            delete this.sources[track];
                        };
                    }
                }

                this.startTime = currentTime - offset;
                this.isPlaying = true;
                this.updatePlayButton();

                // Start progress update
                this.updateProgress();
            }

            pause() {
                this.pauseTime = this.audioContext.currentTime - this.startTime;
                
                for (const track of Object.keys(this.sources)) {
                    if (this.sources[track]) {
                        this.sources[track].stop();
                        delete this.sources[track];
                    }
                }

                this.isPlaying = false;
                this.updatePlayButton();
            }

            stop() {
                this.pause();
                this.pauseTime = 0;
                this.currentTime = 0;
                this.updateProgress();
            }

            seek(e) {
                if (!this.audioContext || this.duration === 0) return;

                const rect = e.currentTarget.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const percent = x / rect.width;
                const seekTime = percent * this.duration;

                const wasPlaying = this.isPlaying;
                this.pause();
                this.pauseTime = seekTime;
                
                if (wasPlaying) {
                    this.play();
                } else {
                    this.updateProgress();
                }
            }

            updateProgress() {
                if (this.isPlaying && this.audioContext) {
                    this.currentTime = this.audioContext.currentTime - this.startTime;
                } else {
                    this.currentTime = this.pauseTime;
                }

                const percent = this.duration > 0 ? (this.currentTime / this.duration) * 100 : 0;
                document.getElementById('progress-fill').style.width = `${percent}%`;
                document.getElementById('current-time').textContent = this.formatTime(this.currentTime);

                if (this.isPlaying) {
                    requestAnimationFrame(() => this.updateProgress());
                }
            }

            updateTotalTime() {
                document.getElementById('total-time').textContent = this.formatTime(this.duration);
            }

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            updatePlayButton() {
                const button = document.getElementById('play-button');
                if (this.isPlaying) {
                    button.textContent = '‚è∏ Pause';
                    button.classList.add('playing');
                } else {
                    button.textContent = '‚ñ∂ Play';
                    button.classList.remove('playing');
                }
            }

            async exportStem(track) {
                if (!this.audioBuffers[track]) {
                    this.showStatus(`${track} stem not loaded`, 'error');
                    return;
                }

                try {
                    const displayName = this.trackLabels[track] || track;
                    this.showStatus(`Exporting ${displayName}...`, 'loading');

                    // Convert to WAV
                    const wav = this.audioBufferToWav(this.audioBuffers[track]);

                    // Create download link with custom label
                    const filename = (this.trackLabels[track] || track).replace(/[^a-z0-9]/gi, '_').toLowerCase();
                    const blob = new Blob([wav], { type: 'audio/wav' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${filename}_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.wav`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    this.showStatus(`${displayName} exported!`, 'success');
                } catch (error) {
                    console.error('Export error:', error);
                    this.showStatus(`Export failed: ${error.message}`, 'error');
                }
            }

            async exportAudio() {
                if (Object.keys(this.audioBuffers).length === 0) {
                    this.showStatus('Please load audio files first', 'error');
                    return;
                }

                const exportButton = document.getElementById('export-button');
                exportButton.disabled = true;
                this.showStatus('Exporting audio... This may take a moment.', 'loading');

                try {
                    // Create offline audio context for rendering
                    const sampleRate = this.audioContext.sampleRate;
                    const maxLength = Math.max(...Object.values(this.audioBuffers).map(b => b.length));
                    
                    const offlineContext = new OfflineAudioContext(
                        this.audioBuffers[Object.keys(this.audioBuffers)[0]].numberOfChannels,
                        maxLength,
                        sampleRate
                    );

                    // Create a master gain node
                    const masterGain = offlineContext.createGain();
                    masterGain.connect(offlineContext.destination);

                    // Mix all tracks (excluding mix track, but including child tracks)
                    for (const track of this.tracks) {
                        // Skip mix track - it's the original, not a stem to mix
                        if (track === 'mix') continue;
                        
                        if (this.audioBuffers[track] && this.gainNodes[track]) {
                            const source = offlineContext.createBufferSource();
                            source.buffer = this.audioBuffers[track];
                            
                            // Create gain node with current volume settings
                            const gainNode = offlineContext.createGain();
                            const currentGain = this.gainNodes[track].gain.value;
                            gainNode.gain.value = currentGain;
                            
                            source.connect(gainNode);
                            gainNode.connect(masterGain);
                            source.start(0);
                        }
                    }

                    // Render the audio
                    const renderedBuffer = await offlineContext.startRendering();
                    
                    // Convert to WAV
                    const wav = this.audioBufferToWav(renderedBuffer);
                    
                    // Create download link
                    const blob = new Blob([wav], { type: 'audio/wav' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `mixed_audio_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.wav`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    this.showStatus('Audio exported successfully!', 'success');
                } catch (error) {
                    console.error('Export error:', error);
                    this.showStatus(`Export failed: ${error.message}`, 'error');
                } finally {
                    exportButton.disabled = false;
                }
            }

            audioBufferToWav(buffer) {
                const length = buffer.length;
                const numberOfChannels = buffer.numberOfChannels;
                const sampleRate = buffer.sampleRate;
                const bytesPerSample = 2;
                const blockAlign = numberOfChannels * bytesPerSample;
                const byteRate = sampleRate * blockAlign;
                const dataSize = length * blockAlign;
                const bufferSize = 44 + dataSize;
                const arrayBuffer = new ArrayBuffer(bufferSize);
                const view = new DataView(arrayBuffer);
                const samples = new Float32Array(length * numberOfChannels);

                // Interleave channels
                let sampleOffset = 0;
                for (let i = 0; i < length; i++) {
                    for (let channel = 0; channel < numberOfChannels; channel++) {
                        samples[sampleOffset++] = buffer.getChannelData(channel)[i];
                    }
                }

                // Write WAV header
                const writeString = (offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };

                writeString(0, 'RIFF');
                view.setUint32(4, bufferSize - 8, true);
                writeString(8, 'WAVE');
                writeString(12, 'fmt ');
                view.setUint32(16, 16, true); // fmt chunk size
                view.setUint16(20, 1, true); // audio format (1 = PCM)
                view.setUint16(22, numberOfChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, byteRate, true);
                view.setUint16(32, blockAlign, true);
                view.setUint16(34, 16, true); // bits per sample
                writeString(36, 'data');
                view.setUint32(40, dataSize, true);

                // Convert float samples to 16-bit PCM
                let dataOffset = 44;
                for (let i = 0; i < samples.length; i++) {
                    const s = Math.max(-1, Math.min(1, samples[i]));
                    view.setInt16(dataOffset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
                    dataOffset += 2;
                }

                return arrayBuffer;
            }

            showStatus(message, type) {
                const statusDiv = document.getElementById('status');
                statusDiv.textContent = message;
                statusDiv.className = `status ${type}`;
                
                if (type === 'success') {
                    setTimeout(() => {
                        statusDiv.textContent = '';
                        statusDiv.className = '';
                    }, 3000);
                }
            }
        }

        // Initialize the editor when page loads
        window.addEventListener('DOMContentLoaded', () => {
            new AudioEditor();
        });
    </script>
</body>
</html>

